uniform shader plane0;
uniform shader plane1;
uniform shader color_cube;
uniform shader lut_indices;
uniform float colorDepth;
uniform float sample_ratio;
uniform int useYCbCrP10;

const int LUT_SIZE = 17;
vec3 C[4];

half4 getOriginalColor(float2 xy) {
    if (useYCbCrP10 == 1) {
        return plane0.eval(xy);
    } else {
        return plane0.eval(xy);
    }
}

half4 getCubeColor(float2 xy) {
    return color_cube.eval(xy);
}

half4 getCubeColor(in ivec3 coor) {
    float2 coor_xy = float2(coor.x * LUT_SIZE + coor.y, coor.z);
    return color_cube.eval(coor_xy);
}

int getIndex(int x, int y) {  // 3,7
    float2 xy = float2(x, y);
    return int(lut_indices.eval(xy).a * 65536.0);
}

int getIndex(float x, float y) {  // 3,7
    float2 xy = float2(x, y);
    return int(lut_indices.eval(xy).a * 65536.0);
}

int getIndex(float2 xy) {
    return int(lut_indices.eval(xy).a * 65536.0);
}

ivec2 findIndex(in int icolor, in int index) {
    if (icolor < getIndex(0, index)) return ivec2(0, 0);
    for (int i=0; i<LUT_SIZE-1; i++) {
        if (icolor < getIndex(i+1, index)) return ivec2(i, i+1);
    }
    return ivec2(LUT_SIZE-1, LUT_SIZE-1);
}

void findIndices(in ivec3 icolor, out ivec3[2] indices) {
    ivec2 xLU = findIndex(icolor.x, 0);
    ivec2 yLU = findIndex(icolor.y, 1);
    ivec2 zLU = findIndex(icolor.z, 2);

    indices[0] = ivec3(xLU.x, yLU.x, zLU.x);
    indices[1] = ivec3(xLU.y, yLU.y, zLU.y);
}

int getTetrahedralType(in vec3 delta) {
    if (delta.b >= delta.r && delta.r >= delta.g) return 0;
    else if (delta.b >= delta.g && delta.g >= delta.r) return 1;
    else if (delta.g >= delta.b && delta.b >= delta.r) return 2;
    else if (delta.r >= delta.b && delta.b >= delta.g) return 3;
    else if (delta.r >= delta.g && delta.g >= delta.b) return 4;
    else return 5;
}

vec3 calcDelta(in ivec3 color, in ivec3 lower, in ivec3 upper) {
    vec3 nume = vec3(
        float(color.x - getIndex(lower.x, 0)),
        float(color.y - getIndex(lower.y, 1)),
        float(color.z - getIndex(lower.z, 2))
    );
    vec3 denom = vec3(
        float(getIndex(upper.x, 0) - getIndex(lower.x, 0)),
        float(getIndex(upper.y, 1) - getIndex(lower.y, 1)),
        float(getIndex(upper.z, 2) - getIndex(lower.z, 2))
    );
    if (denom.x != 0.0) {
        nume.x = nume.x / denom.x;
    } else {
        nume.x = 0.0;
    }
    if (denom.y != 0.0) {
        nume.y = nume.y / denom.y;
    } else {
        nume.y = 0.0;
    }
    if (denom.z != 0.0) {
        nume.z = nume.z / denom.z;
    } else {
        nume.z = 0.0;
    }

    return nume;
}

vec3 findData(in ivec3 indices) {
    return getCubeColor(indices).xyz;
}

void fillVertices(in ivec3 indices[2], in int tetrahedralType) {
    C[0] = findData(ivec3(indices[0].xyz));
    C[3] = findData(ivec3(indices[1].xyz));

    switch(tetrahedralType) {
    case 0:
        C[1] = findData(ivec3(indices[0].x, indices[0].y, indices[1].z));
        C[2] = findData(ivec3(indices[1].x, indices[0].y, indices[1].z));
        break;
    case 1:
        C[1] = findData(ivec3(indices[0].x, indices[0].y, indices[1].z));
        C[2] = findData(ivec3(indices[0].x, indices[1].y, indices[1].z));
        break;
    case 2:
        C[1] = findData(ivec3(indices[0].x, indices[1].y, indices[0].z));
        C[2] = findData(ivec3(indices[0].x, indices[1].y, indices[1].z));
        break;
    case 3:
        C[1] = findData(ivec3(indices[1].x, indices[0].y, indices[0].z));
        C[2] = findData(ivec3(indices[1].x, indices[0].y, indices[1].z));
        break;
    case 4:
        C[1] = findData(ivec3(indices[1].x, indices[0].y, indices[0].z));
        C[2] = findData(ivec3(indices[1].x, indices[1].y, indices[0].z));
        break;
    case 5:
    default:
        C[1] = findData(ivec3(indices[0].x, indices[1].y, indices[0].z));
        C[2] = findData(ivec3(indices[1].x, indices[1].y, indices[0].z));
        break;
    }
}

half3 tetrahedral(in vec3 d, in int tetrahedralType) {
    vec3 T1xV[4];
    T1xV[0] = C[0];

    switch(tetrahedralType) {
    case 0:
        T1xV[1] = C[1] - C[0];
        T1xV[2] = C[2] - C[1];
        T1xV[3] = C[3] - C[2];
        break;
    case 1:
        T1xV[1] = C[1] - C[0];
        T1xV[2] = C[3] - C[1];
        T1xV[3] = C[2] - C[1];
        break;
    case 2:
        T1xV[1] = C[2] - C[1];
        T1xV[2] = C[3] - C[2];
        T1xV[3] = C[1] - C[0];
        break;
    case 3:
        T1xV[1] = C[2] - C[1];
        T1xV[2] = C[1] - C[0];
        T1xV[3] = C[3] - C[2];
        break;
    case 4:
        T1xV[1] = C[3] - C[2];
        T1xV[2] = C[1] - C[0];
        T1xV[3] = C[2] - C[1];
        break;
    case 5:
    default:
        T1xV[1] = C[3] - C[2];
        T1xV[2] = C[2] - C[1];
        T1xV[3] = C[1] - C[0];
        break;
    }

    vec3 res = T1xV[0] + T1xV[1] * d.b + T1xV[2] * d.r + T1xV[3] * d.g;

    return half3(res);
}

half4 toneMap(float2 xy) {
    vec4 color = getOriginalColor(xy);
    ivec3 icolor;
    icolor.x = int(color.x * colorDepth);
    icolor.y = int(color.y * colorDepth);
    icolor.z = int(color.z * colorDepth);

    ivec3 indices[2];
    findIndices(icolor, indices);

    vec3 delta = calcDelta(icolor, indices[0], indices[1]);
    int tetrahedralType = getTetrahedralType(delta);
    fillVertices(indices, tetrahedralType);

    half3 ret = tetrahedral(delta, tetrahedralType);

    return half4(ret, 1.0);
}

half4 main(float2 xy) {
    float2 new_xy = xy / sample_ratio;
    return toneMap(new_xy);
}
